<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url(https://themes.googleusercontent.com/fonts/css?kit=MXVwpSGzOOhqOc5hUWJbBLizfYjsfH9XaeDpmRKYJN5bV0WvE1cEyAoIq5yYZlSc);ol{margin:0;padding:0}table td,table th{padding:0}.c4{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:justify;height:11pt}.c3{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:20pt;font-family:"Arial";font-style:normal}.c2{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c13{padding-top:20pt;padding-bottom:6pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c15{padding-top:18pt;padding-bottom:4pt;line-height:1.15;orphans:2;widows:2;text-align:justify}.c1{padding-top:12pt;padding-bottom:12pt;line-height:1.15;orphans:2;widows:2;text-align:justify}.c10{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c8{color:#188038;text-decoration:none;vertical-align:baseline;font-family:"Roboto Mono";font-style:normal}.c0{color:#188038;font-weight:400;font-family:"Roboto Mono"}.c9{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c7{font-size:17pt;font-weight:700}.c6{font-weight:700;font-style:italic}.c11{page-break-after:avoid}.c14{font-weight:700}.c5{height:11pt}.c12{font-style:italic}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:12pt;color:#000000;font-size:11pt;padding-bottom:12pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:justify}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c9 doc-content"><h1 class="c13 c11" id="h.74m2quqk68ig"><span class="c3">Core Idea</span></h1><p class="c5 c10"><span class="c2"></span></p><p class="c1"><span class="c2">A simple chatroom is, at its heart, a place where people can type messages and see what others say in real time, sharing one shared stream of conversation. In this project, that place is not a web page or a mobile app, but the terminal itself. Every person runs a small Python program called a client, and all of those clients talk to another Python program called the server. The server sits in the middle, quietly listening. Whenever one client sends a message, the server takes that message and delivers it to every other connected client. To each user, it feels like everyone is sitting in the same room, even though they are really just sending lines of text over the network.</span></p><p class="c1"><span class="c2">The core idea of this application is very simple: many clients, one server, one shared conversation. There are no private rooms, no message history, no usernames stored in a database. A user connects, types something, sees what others type, and can leave at any time. This simplicity is helpful. It allows us to focus on understanding how network communication works, how data moves between machines, and how to manage several users at once without making the program too complicated. Even with this small feature set, the chatroom already feels alive: when two or more terminals start sending messages and you see them appear in real time, you can immediately see that your code is doing something real.</span></p><h1 class="c1 c11" id="h.svzqb6ohryt0"><span class="c3">Required Modules</span></h1><p class="c1"><span>To make this work in Python, we rely on three important modules: </span><span class="c14">socket</span><span>, </span><span class="c14">select</span><span>, and </span><span class="c14">sys</span><span class="c2">. Each of them solves a specific problem that appears as soon as you try to move beyond a single program talking only to itself.</span></p><h1 class="c11 c13" id="h.ixbylpe0mj7c"><span class="c3">Socket module</span></h1><p class="c1"><span>The </span><span class="c12">socket</span><span>&nbsp;module is the bridge between the Python code and the network. Without it, the program would have no direct way to send information to another machine across the internet or even across the local computer. A &ldquo;socket&rdquo; is like a virtual plug point where data can flow in and out. On the server side, the socket is created, binded to a specific address and port, and listens for new connections. On the client side, another socket is created and connected to the server&rsquo;s address and port. Once the connection is made, both sides can send and receive bytes through this link. This is what turns a simple line of text inside your program into something that can travel to someone else&rsquo;s screen. The </span><span class="c12">socket</span><span class="c2">&nbsp;module hides many of the low-level details of networking and gives you a clear set of functions to open connections, accept clients, and exchange messages. It is the foundation of the chatroom.</span></p><p class="c1 c5"><span class="c2"></span></p><h1 class="c13 c11" id="h.ca1q5l99aehq"><span class="c3">Select module</span></h1><p class="c1"><span>When only one client is connected, life is easy: the server can read from that one socket, then write to it, and everything is fine. The problem appears the moment there are several clients at once. The server now has many sockets open, one for each client, and it must be ready to read data from any of them whenever a user sends a message. It cannot simply &ldquo;block&rdquo; and wait forever on one client, because then it would ignore everyone else. This is where the </span><span class="c6">select</span><span>&nbsp;module becomes important. The </span><span class="c6">select</span><span>&nbsp;module allows the server to watch several sockets at the same time and ask a simple question: &ldquo;Which of these are ready right now?&rdquo; Instead of getting stuck waiting on one connection, the server uses </span><span class="c6">select</span><span class="c2">&nbsp;to get a list of all sockets that have data waiting. It can then quickly loop over them, read the new messages, and broadcast them. This technique is called I/O multiplexing. It lets us build a responsive multi-user chat without using multiple threads or complex frameworks, and it keeps the code small and easier to understand.</span></p><h1 class="c1 c11" id="h.o9il753f8v78"><span class="c3">sys module</span></h1><p class="c1"><span>The </span><span class="c6">sys</span><span>&nbsp;module plays a quieter but still useful role. It connects your Python program to the environment it is running in. Through </span><span class="c6">sys.argv</span><span>, you can read command-line arguments, such as the server address or port number, so that you do not have to hard-code them inside the script. Through </span><span class="c6">sys.stdin</span><span>&nbsp;and </span><span class="c6">sys.stdout</span><span class="c2">, your program can work directly with input and output streams. In a terminal chat client, we often need to read what the user types and send it over the network while also listening for incoming messages from the server. By combining sys.stdin with select, the client can check both: if the user has typed something, it reads from standard input and sends the message; if the server has sent something, it reads from the socket and prints the message. The sys module makes this coordination between the user, the terminal, and the network smooth and flexible.</span></p><p class="c1"><span class="c2">Together, these three modules support the main features of our simple chatroom. The server can accept many clients, handle all of them from a single loop, and forward messages to everyone. Each client can type messages and see others&rsquo; messages appear almost immediately in the same terminal window. There is no complex interface, no graphics, and no extra decoration. This is deliberate. By stripping away everything unnecessary, the project lets you see clearly how real-time communication is built: open sockets, check who is talking, move bytes from one place to another, and display them as readable text.</span></p><p class="c1"><span class="c2">Once this foundation is solid, it becomes easy to imagine extensions. You can add nicknames, timestamps, colored output, simple commands, or even private messages. But those are steps for later. For now, the goal is a clean, working, many-to-one-to-many conversation loop. With socket to connect, select to manage many connections at once, and sys to talk to the terminal and read arguments, you have everything you need to bring this small chatroom to life.</span></p><p class="c1 c5"><span class="c2"></span></p><p class="c4"><span class="c2"></span></p><p class="c4"><span class="c2"></span></p><h2 class="c15" id="h.8gkzbz72f08p"><span class="c7">Understanding </span><span class="c8 c7">server.py</span></h2><p class="c1"><span>At the top of the file, the server imports three modules: </span><span class="c0">socket</span><span>, </span><span class="c0">select</span><span>, and </span><span class="c0">sys</span><span>. The </span><span class="c0">socket</span><span>&nbsp;module is what lets Python talk over the network. The </span><span class="c0">select</span><span>&nbsp;module lets the server watch many connections at once without getting stuck on just one. The </span><span class="c0">sys</span><span class="c2">&nbsp;module gives access to command-line arguments and lets the program exit in a controlled way. These three imports set the stage.</span></p><p class="c1"><span>Next comes the </span><span class="c0">broadcast</span><span>&nbsp;function. It is defined with four parameters: </span><span class="c0">message</span><span>, </span><span class="c0">sender_socket</span><span>, </span><span class="c0">sockets_list</span><span>, and </span><span class="c0">clients</span><span>. This function is responsible for sending a given message to every client except the one that sent it and the server itself. Inside the function, there is a simple loop over </span><span class="c0">sockets_list</span><span>. For each </span><span class="c0">sock</span><span>, the code checks that this socket is not the </span><span class="c0">sender_socket</span><span>&nbsp;and is not </span><span class="c0">server_socket</span><span>&nbsp;(the main listening socket). If it passes this check, the server tries to send the message using </span><span class="c0">sock.send(message)</span><span>. If sending fails for some reason (for example, if the client has disappeared), the </span><span class="c0">except</span><span>&nbsp;block closes that socket, removes it from </span><span class="c0">sockets_list</span><span>, and, if it exists in the </span><span class="c0">clients</span><span class="c2">&nbsp;dictionary, removes it from there too. This small function hides the logic of &ldquo;tell everyone else&rdquo; so that later code is easier to read.</span></p><p class="c1"><span>After defining </span><span class="c0">broadcast</span><span>, the server checks if the user provided exactly one command-line argument (the port number). When a Python program runs from the terminal, it can receive extra information typed after the file name. This information is called command-line arguments. In Python, all these arguments are automatically stored in a list named </span><span class="c0">sys.argv</span><span>. The first item in that list, </span><span class="c0">sys.argv[0]</span><span>, is always the name of the program itself, and the next items are whatever the user typed after it. &nbsp;It looks at </span><span class="c0">len(sys.argv) != 2</span><span>. This line simply asks, &ldquo;Did the user give me exactly two items in that list?&rdquo; One item should be the program name, and the second should be the port number where the server will listen for clients. If the user forgets to type the port number, or if they type something extra, the program will notice that the number of arguments is not correct. When that happens, it prints a friendly message showing the right way to run the program, such as &ldquo;Usage: python server.py &lt;port&gt;&rdquo;. This message acts like a quick help guide, reminding the user to include a port number when starting the server. After printing that message, the program calls </span><span class="c0">sys.exit(1)</span><span class="c2">&nbsp;to stop running. The number one inside the parentheses means the program is ending because of a problem or mistake in how it was started. This prevents the server from running without the information it needs.</span></p><p class="c1"><span>If the argument count is correct, the code takes </span><span class="c0">sys.argv[1]</span><span>, converts it to an integer, and stores it in </span><span class="c0">PORT</span><span>. This </span><span class="c0">PORT</span><span class="c2">&nbsp;is the number on which the server will listen for connections.</span></p><p class="c1"><span>Now the actual server socket is created. The line </span><span class="c0">server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><span>&nbsp;tells Python to create an IPv4 TCP socket. TCP is used because it is reliable and keeps a connection open between client and server. Immediately after that, </span><span class="c0">server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</span><span class="c2">&nbsp;is called. This line allows the operating system to quickly reuse the same address and port if you restart the server, instead of making you wait.</span></p><p class="c1"><span>The server then binds and starts listening. The line </span><span class="c0">server_socket.bind((&quot;0.0.0.0&quot;, PORT))</span><span>&nbsp;attaches the socket to all network interfaces on the machine on that given port. The call </span><span class="c0">server_socket.listen()</span><span class="c2">&nbsp;tells the socket to start listening for incoming connections. Right after that, the server prints a message to the terminal saying that it has started and is waiting for connections. </span></p><p class="c1"><span>The next important step is to create </span><span class="c0">sockets_list = [server_socket]</span><span>. This list will hold all sockets that the server needs to watch: at the beginning, it only includes the listening server socket itself. Over time, it will also include every connected client socket. Alongside this, the code creates </span><span class="c0">clients = {}</span><span class="c2">, an empty dictionary that will map each client socket to its address (IP and port), mainly so the server can print and send messages identifying who spoke or who left.</span></p><p class="c1"><span>The main work of the server happens inside a </span><span class="c0">try</span><span>&nbsp;block with </span><span class="c0">while True</span><span>. This loop runs forever while the server is active. At the start of each loop, the server calls </span><span class="c0">select.select(sockets_list, [], sockets_list)</span><span>. This means: &ldquo;watch all sockets in </span><span class="c0">sockets_list</span><span>and tell me which ones are ready to be read, and also which ones have errors.&rdquo; The result is three lists, but here we only use </span><span class="c0">read_sockets</span><span>&nbsp;and </span><span class="c0">exception_sockets</span><span>. Any socket in </span><span class="c0">read_sockets</span><span class="c2">&nbsp;has something interesting happening: either a new connection is waiting on the server socket, or a client has sent data, or a client has closed the connection.</span></p><p class="c1"><span>The code then loops over each </span><span class="c0">notified_socket</span><span>&nbsp;in </span><span class="c0">read_sockets</span><span>. If </span><span class="c0">notified_socket</span><span>&nbsp;is the </span><span class="c0">server_socket</span><span>, that means a new client is trying to connect. The server calls </span><span class="c0">server_socket.accept()</span><span>, which returns a </span><span class="c0">client_socket</span><span>&nbsp;and </span><span class="c0">client_address</span><span>. It then adds this </span><span class="c0">client_socket</span><span>&nbsp;to </span><span class="c0">sockets_list</span><span>&nbsp;so it will be watched in future, and stores the address in </span><span class="c0">clients[client_socket] = client_address</span><span>. To let others know someone has arrived, it creates a message like </span><span class="c0">[Server] 192.168.1.5:50532 joined the chat.</span><span>&nbsp;and prints it on the server. Then it calls </span><span class="c0">broadcast</span><span class="c2">&nbsp;with this join message so all the other clients see that someone has joined.</span></p><p class="c1"><span>If </span><span class="c0">notified_socket</span><span>&nbsp;is not the server socket, then it must be one of the connected clients. In this case, the server tries to read from it using </span><span class="c0">message = notified_socket.recv(1024)</span><span>. If an error happens during reading, it sets </span><span class="c0">message = b&quot;&quot;</span><span>. After this, it checks </span><span class="c0">if not message:</span><span>. An empty message means the client has closed the connection or disconnected. When that happens, the server looks up the client&rsquo;s address in </span><span class="c0">clients</span><span>, creates a &ldquo;left the chat&rdquo; message, prints it, removes this socket from </span><span class="c0">sockets_list</span><span>&nbsp;and from </span><span class="c0">clients</span><span>, closes the socket, and calls </span><span class="c0">broadcast</span><span class="c2">&nbsp;so all other clients know that this user has gone.</span></p><p class="c1"><span>If the message is not empty, that means the client has sent some text. The server looks up the address of the sender in </span><span class="c0">clients</span><span>. It decodes the bytes to a string with </span><span class="c0">message.decode(errors=&quot;ignore&quot;)</span><span>, removes extra newline at the end with </span><span class="c0">rstrip()</span><span>, and then builds a formatted line like </span><span class="c0">[192.168.1.5:50532] hello everyone</span><span>. It prints this line on the server so the operator can see all chat messages. Then it calls </span><span class="c0">broadcast</span><span>&nbsp;with this formatted message, passing </span><span class="c0">notified_socket</span><span class="c2">&nbsp;as the sender, so that everyone except the sender receives it.</span></p><p class="c1"><span>After processing readable sockets, the code checks </span><span class="c0">exception_sockets</span><span>. Any socket that appears there has some kind of error. For each of those sockets, it removes them from </span><span class="c0">sockets_list</span><span>&nbsp;and </span><span class="c0">clients</span><span class="c2">&nbsp;if present, and then closes them. This keeps the server clean and avoids broken connections staying around.</span></p><p class="c1"><span>The whole loop is wrapped in a </span><span class="c0">try</span><span>&nbsp;so that if you press </span><span class="c0">Ctrl+C</span><span>&nbsp;to stop the server, the </span><span class="c0">except KeyboardInterrupt</span><span>&nbsp;block runs. In this block, it prints &ldquo;Shutting down server...&rdquo;, then loops over all sockets in </span><span class="c0">sockets_list</span><span class="c2">&nbsp;and closes them, and finally exits the program. </span></p><p class="c1"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p><h2 class="c15" id="h.5h9qc58c9vfw"><span class="c7">Understanding </span><span class="c7 c8">client.py</span></h2><p class="c1"><span class="c2">The client script is the user&rsquo;s door into the chatroom. It is simpler than the server, but it must do one important trick: it has to both read user input and listen for incoming messages at the same time.</span></p><p class="c1"><span>At the top, the script imports </span><span class="c0">socket</span><span>, </span><span class="c0">select</span><span>, and </span><span class="c0">sys</span><span>, just like the server. The </span><span class="c0">socket</span><span>&nbsp;module is for connecting to the server. The </span><span class="c0">select</span><span>&nbsp;module is for watching both the socket and the keyboard input. The </span><span class="c0">sys</span><span class="c2">&nbsp;module is for reading command-line arguments and handling exit.</span></p><p class="c1"><span>The client program needs two pieces of information instead of one: the host address and the port number. The line </span><span class="c0">if len(sys.argv) != 3:</span><span>&nbsp;checks if there are exactly three items in the list: the name of the file, the host address, and the port number. If the user forgets to write one of them, the client program cannot connect to the server because it does not know where to go. To help the user, the program prints another usage message that says something like &ldquo;Usage: python client.py &lt;host&gt; &lt;port&gt;&rdquo;. This message explains that the correct way to start the client is to include both the host address and the port number. For example, a user might type &ldquo;python client.py 127.0.0.1 5000&rdquo; to connect to a server running on the same computer. After showing the correct usage, the program again calls </span><span class="c0">sys.exit(1)</span><span>&nbsp;to stop running, because it cannot continue without this information. If the input is good, it reads </span><span class="c0">HOST = sys.argv[1]</span><span>&nbsp;and </span><span class="c0">PORT = int(sys.argv[2])</span><span class="c2">. Now the client knows where to connect.</span></p><p class="c1"><span>Then the client creates its socket with </span><span class="c0">client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><span>, once again using an IPv4 TCP socket. In a </span><span class="c0">try</span><span>&nbsp;block, it calls </span><span class="c0">client_socket.connect((HOST, PORT))</span><span>. If this fails, for example because the server is not running or the address is wrong, the </span><span class="c0">except</span><span class="c2">&nbsp;block prints an error message showing why it could not connect, and exits. If it succeeds, it prints a friendly message: it tells the user that it is connected to the server, and explains briefly how to type and how to quit.</span></p><p class="c1"><span>Now comes the main loop of the client. It is inside a </span><span class="c0">try</span><span>&nbsp;block with </span><span class="c0">while True</span><span>, so it runs continuously until the user or the server stops it. Inside the loop, the client builds a list called </span><span class="c0">sockets_list = [sys.stdin, client_socket]</span><span class="c2">. This list contains two things: the standard input (what the user types in the terminal) and the network socket connected to the server.</span></p><p class="c1"><span>The client calls </span><span class="c0">select.select(sockets_list, [], [])</span><span>. This means: &ldquo;wait until either the user has typed something, or the server has sent something.&rdquo; The call returns </span><span class="c0">read_sockets</span><span>&nbsp;and two other lists we do not use here. The client then loops over each </span><span class="c0">notified_socket</span><span>&nbsp;in </span><span class="c0">read_sockets</span><span class="c2">.</span></p><p class="c1"><span>If </span><span class="c0">notified_socket</span><span>&nbsp;is </span><span class="c0">client_socket</span><span>, that means there is new data from the server, so the client calls </span><span class="c0">client_socket.recv(1024)</span><span>&nbsp;to read up to 1024 bytes. If the returned </span><span class="c0">message</span><span>&nbsp;is empty, that means the server has closed the connection. In that case, it prints a message saying it has been disconnected, closes the socket, and exits. If the message is not empty, it decodes the bytes to text with </span><span class="c0">message.decode(errors=&quot;ignore&quot;)</span><span>, writes it to standard output with </span><span class="c0">sys.stdout.write(...)</span><span class="c2">, and flushes so it appears immediately. The formatting of these messages has already been done by the server, so the client just prints them.</span></p><p class="c1"><span>If </span><span class="c0">notified_socket</span><span>&nbsp;is not </span><span class="c0">client_socket</span><span>, then it must be </span><span class="c0">sys.stdin</span><span>. That means the user has typed a line and pressed Enter. The client reads that line with </span><span class="c0">message = sys.stdin.readline()</span><span>. If this returns an empty string, it usually means the user signaled end-of-input (for example with </span><span class="c0">Ctrl+D</span><span>), so the client prints a message about closing the connection, closes the socket, and exits. If there is some text, it encodes this string into bytes with </span><span class="c0">message.encode()</span><span>&nbsp;and sends it to the server using </span><span class="c0">client_socket.send(...)</span><span class="c2">. The server will then handle broadcasting it to everyone else.</span></p><p class="c1"><span>The whole loop is wrapped in a </span><span class="c0">try</span><span>&nbsp;so that when the user presses </span><span class="c0">Ctrl+C</span><span>, the </span><span class="c0">except KeyboardInterrupt</span><span class="c2">&nbsp;block runs. This prints a short &ldquo;Closing connection.&rdquo; message, closes the socket, and exits. </span></p><h1 class="c1 c11" id="h.vqz4dhh8btxf"><span class="c3">Pinggy</span></h1><p class="c1"><span class="c2">When the chatroom is first created, both the server and the clients are designed to work only within the same computer or local network. Connections are made through the address &ldquo;localhost&rdquo; or &ldquo;127.0.0.1,&rdquo; which means that all communication happens internally on the same machine. This setup is ideal for testing, but it prevents users from other locations from joining the chat, because the computer running the server is usually hidden behind a router and does not have a public address that can be reached directly. To make the local server accessible from the internet, a tunneling service such as Pinggy can be used. Through this service, a secure tunnel is created between the local machine and a public server operated by Pinggy.</span></p><p class="c1"><span>By using Pinggy, a connection is established that allows all incoming traffic from the internet to be forwarded to the local server. This is done through a short SSH command, which tells Pinggy which local port should be linked to the public address. In this project, the server is set to listen on port 12345, so the command is written in a way that any incoming request to Pinggy&rsquo;s public address is redirected to </span><span class="c0">localhost:12345</span><span>&nbsp;on the user&rsquo;s machine. Once the tunnel is successfully created, a special public address is provided by Pinggy. It appears in the terminal in a form similar to </span><span class="c0">tcp://gbwmz-79-209-41-48.a.free.pinggy.link:46229</span><span class="c2">. This address serves as the entry point through which users on the internet can reach the chat server running locally.</span></p><p class="c1"><span class="c2">After the tunnel is created, the server continues to operate on the local computer exactly as before, but all communication from the outside world is automatically passed through Pinggy. When a remote client connects to the public address provided by Pinggy, the data is received by Pinggy&rsquo;s server and then securely forwarded to the chat server running on the user&rsquo;s machine. From the client&rsquo;s perspective, the connection feels no different from connecting to a regular online server. The local computer becomes accessible over the internet without any changes being required in the code.</span></p><p class="c1"><span>Once the public address and port are provided by Pinggy, they can be shared with anyone who wishes to join the chatroom. The same </span><span class="c0">client.py</span><span>&nbsp;program is used by the remote participants, but instead of typing </span><span class="c0">127.0.0.1</span><span>&nbsp;or </span><span class="c0">localhost</span><span>, the host and port given by Pinggy are entered. In this example, the host is </span><span class="c0">gbwmz-79-209-41-48.a.free.pinggy.link</span><span>, and the port is </span><span class="c0">46229</span><span class="c2">. When the client is started with these values, the connection is routed through Pinggy to the local server, allowing real-time communication between people in different locations.</span></p><p class="c1"><span class="c2">No modifications to the server or client code are required for this process to work. The server is already configured to listen on all interfaces through the address &ldquo;0.0.0.0,&rdquo; and the client is already able to accept any host and port as input. The only important condition is that the same port number used in the server program must also be the one specified in the Pinggy command. When this requirement is met, Pinggy is able to forward traffic correctly to the server.</span></p><p class="c1"><span class="c2">Through this setup, a local chatroom is effectively transformed into a global one. The server continues to run on the user&rsquo;s own computer, but by means of the Pinggy tunnel, it is made reachable from anywhere on the internet. Users from different places can connect to the public address, and their messages are transmitted securely to the local server, making the chatroom available to the world without any complex network configuration.</span></p><p class="c4"><span class="c2"></span></p></body></html>